## 描述

给定一个字符串，请你找出其中不含有重复字符的**最长子串**的长度。

> 示例  1:
>
> 输入: s = "abcabcbb"
>
> 输出: 3
>
> 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。

> 示例 2:
>
> 输入: s = ""
>
> 输出: 0

> 提示：
>
> - 0 <= s.length <= 5 \* 104
> - s:由英文字母、数字、符号和空格组成

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/longest-substring-without-repeating-characters

## 思路

1. 寻找到所有不重复的子串
2. 找到其中最长的一个子串，返回其长度
   > 难点在第一步，怎么找出所有不重复的子串呢？
   >
   > 1. 首先我们利用双指针去维护一个**滑动窗口**
   > 2. 右指针不断向右移动，并在字典表中（Map）记录每次移动过程中出现的值
   > 3. 当有指针在移动过程中发现该值已经在字典中存在，则将做指针移动到记录值下标的+1 位置（这里需要注意，这个值要满足两个条件，在字典表中存在，并且字典中记录的位置要大于等于左指针，确保该值仍然在当前窗口中）
   > 4. 不断更新子串的长度，找到最大的即可

## 题解

```js
/**
 * @param {string} s
 * @return {number}
 */
var lengthOfLongestSubstring = function (s) {
  // 窗口左指针
  let l = 0;
  // 需要返回的最大长度
  let maxLen = 0;
  // 记录每次的出现的值
  const m = new Map();
  // 遍历字符
  for (let r = 0; r < s.length; r++) {
    // 记录当前字符
    const c = s[r];
    // 如果出现重复的值，并且在当且窗口内
    if (m.has(c) && m.get(c) >= l) {
      // 左指针移动到出现的重复值的下标 + 1处，即更新窗口，去除重复值
      l = m.get(c) + 1;
    }
    // 更新最大的子串长度
    maxLen = Math.max(maxLen, r - l + 1);
    // 存入字典表中：[字符，下标]
    m.set(c, r);
  }
  // 返回最长的子串长度
  return maxLen;
};
```

## 复杂度分析

假设字符串的长度为 n

- 时间复杂度：**O(n)**，因为会遍历整个字符串的长度
- 空间复杂度：**O(∣Σ∣)**，Σ 表示字符集，∣Σ∣ 表示字符集的长度，因为 map 中存储的字符，遇到重复的会直接覆盖，所以最坏的情况下会存储所有的字符，也就是 ∣Σ∣ 个。
  > 本题中没有明确说明字符集，因此可以默认为所有 ASCII 码在 [0, 128)[0,128) 内的字符，即 |\Sigma| = 128∣Σ∣=128。我们需要用到哈希集合来存储出现过的字符，而字符最多有 |\Sigma|∣Σ∣ 个，因此空间复杂度为 O(|\Sigma|)O(∣Σ∣)。
