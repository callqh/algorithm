## 描述

一个数对  (a,b)  的 数对和   等于  a + b 。最大数对和   是一个数对数组中最大的   数对和  。

比方说，如果我们有数对  (1,5) ，(2,3)  和  (4,4)，最大数对和   为  max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8 。
给你一个长度为 偶数  n  的数组  nums ，请你将 nums  中的元素分成 n / 2  个数对，使得：

nums  中每个元素   恰好   在 一个   数对中，且
最大数对和   的值 最小  。
请你在最优数对划分的方案下，返回最小的 最大数对和  。

> 示例 1：

> 输入：nums = [3,5,2,3]
> 输出：7
>
> 解释：数组中的元素可以分为数对 (3,3) 和 (5,2) 。
>
> 最大数对和为 max(3+3, 5+2) = max(6, 7) = 7 。

来源：力扣（LeetCode）

链接：https://leetcode-cn.com/problems/minimize-maximum-pair-sum-in-array

著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 思路

1. 通过题意可以知道最大数对和就是就是两个数组成的数对中，相加起来的和最大就 ok
2. 根据第一条的理解，我们可以通过先排序，将数组变成一个升序数组
3. 然后通过首尾两个指针进行对撞，来完成最大和的组合
   - 首： 数组中的第一项
   - 尾： 数组中的最后一项

> 因为我们通过排序已经形成了一个升序数组，所以首尾相加的时候，就是最小值+最大值，这样很容易就形成一个最大数对和，最后我们再将指针对撞过程中计算出来的最大值返回即可

> 对于数组类的问题，如果正常数组没办法完成我们的需求，可以考虑先将数组排序之后再进行操作
> 类似于，如果正常双指针没办法完成需求，可以使用对撞指针的操作来完成

## 题解

```js
/**
 * @param {number[]} nums
 * @return {number}
 */
var minPairSum = function (nums) {
  // 排序数组
  nums.sort((a, b) => a - b);
  // 定义首尾指针
  let l = 0;
  let r = nums.length - 1;
  let ans = 0;
  // 边界条件，因为是偶数，所以l不会等于r，只会比r大，当大于的时候就终止遍历就ok
  while (l < r) {
    ans = Math.max(ans, nums[l] + nums[r]);
    l++;
    r--;
  }
  return ans;
};
```

## 复杂度分析

假设数组的长度为 n：

- 时间复杂度：**O(n)** 因为需要经过一次排序和遍历
- 空间复杂度：**O(1)** 只需要一个常量级的变量存储
